## Process

The software engineering process is divided into three main phases:

1. **Development**
2. **Operation**
3. **Maintenance**

### Development

This is the initial and typically shorter phase focused mainly on developers. It involves:

- **Requirements Engineering**: Defining the functionalities of the product, including what it aims to do and who will use it.
- **Design**: Specifying the parts of the product, both physical and logical, and organizing them.
- **Implementation**: Building the product by creating and integrating its units.

#### Key Activities in Development:
- **Prototypes**: Creating high or low fidelity sketches and mock-ups.

### Operation & Maintenance

This is a longer phase, affecting mainly the users, where the product is actively used and maintained.

- **Verification and Validation (V&V)**: Ensuring the solutions align with the requirements and are correctly implemented.
- **Testing**: Conducting unit, integration, and acceptance tests.
- **User Feedback**: Gathering insights through interviews, ethnographic studies, and focus groups.
- **Management**: Handling configuration, quality, project planning, tracking, and budgeting.

### Iterative Process

Software engineering often follows an Agile methodology, where phases are repeated to ensure the product meets the requirements as closely as possible.

## Goals

The primary goal is to produce software with defined properties regarding cost, duration, and functionality. The process can be seen as both:

- **Top-Down**: Starting from requirements and moving through design and implementation, followed by verification.
- **Bottom-Up**: Starting with a high-level definition and then implementing individual parts.

## Requirements

### Importance of Requirements

Requirements define the product properties and ensure the final product resonates with user needs. They are documented in a requirements document, which includes:

- **Informal Description**: Provided by the user or stakeholder.
- **Business Model**: Outlining the business aspects.
- **Stakeholders**: Identifying everyone involved in the development.
- **Context Diagram**: Showing how different stakeholders and entities interact with the product.
- **Interfaces**: Defining physical and logical interactions.
- **Functional Requirements**: Describing what the product should do.
- **Non-Functional Requirements**: Describing how the product should perform its functions.

### Detailed Elements in Requirements Document

1. **Informal Description**: Stakeholder descriptions of needs and wants.
2. **Stakeholders**: All interested parties, including users, developers, and third parties.
3. **Context Diagram**: “In” and “Out” flow related to the product context.
4. **Functional Requirements**: Services and main functionalities.
5. **Non-Functional Requirements**: Usability, efficiency, reliability, maintainability, portability, security, and safety.
6. **Glossary & Class Diagram**: Definitions and relationships of entities.
7. **System Design**: High-level operation and subsystem relationships.
8. **Deployment Diagram**: Distribution of product parts and interactions with external components.
9. **Scenarios & Use Cases**: Different execution scenarios for each use case.

## System Design

Describes the system's operation, subsystem relationships, and interaction with external components.

## Deployment Diagram

Details the deployment of product components and interactions with external systems.

## Scenarios & Use Cases

Scenarios describe possible product usages and outcomes based on functional requirements. They include:

- **Nominal**: Correct execution.
- **Exceptional**: Incorrect execution.

## Relationships

Defines how elements are associated:

- **Generalization**: A general case with a special case (e.g., supervisor is a specific case of a salesperson).
- **Multiplicity**: Maximum number of links between items.
- **Aggregation**: Part-whole relationship where the part can exist independently.
- **Composition**: Stronger part-whole relationship where the part cannot exist without the whole.

## Teams and Teamwork

### Team Characteristics

- **Size**: Ideal team size is 4-7 members to avoid communication issues.
- **Norms**: Productivity and protest norms to manage work and conflict.
- **Specialization**: Whether tasks are specialized or shared among team members.
- **Leadership**: Should emerge democratically for better team dynamics.

### Individual Traits

Based on Myers-Briggs "Big Five" personality traits:

- **Neuroticism**
- **Openness**
- **Conscientiousness**
- **Extraversion**
- **Agreeableness**

## Project Management

Project management is the initial and continuous phase of the software engineering process, involving:

- **Initial Estimation**: Planning and estimating time and cost, recognizing that initial estimates are rarely accurate.
- **Tracking**: Monitoring progress throughout the process.

### Key Management Activities

- **Estimation**: Determining how much and when.
- **Scheduling**: Planning timelines and milestones.
- **Tracking**: Regularly checking progress against the plan.

## Summary

- **Iterative Process**: Agile methodology ensures continuous improvement.
- **Requirements**: Critical for defining product properties and guiding development.
- **Teamwork**: Effective teams enhance productivity and innovation.
- **Project Management**: Essential for planning, tracking, and successful project completion.

---

**Images Placeholder**

![Context Diagram](image-context-diagram.png)  
*Description: Diagram showing the "In" and "Out" flow related to the product context.*

![Class Diagram](image-class-diagram.png)  
*Description: Diagram depicting the relationships between different entities within the product.*

![Deployment Diagram](image-deployment-diagram.png)  
*Description: Diagram illustrating the deployment of product components and their interactions with external systems.*

![Use Case Diagram](image-use-case-diagram.png)  
*Description: Diagram outlining the various use cases for the product and the scenarios associated with each.*

